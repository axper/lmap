\documentclass[12pt]{article}
\usepackage{polyglossia}
\usepackage{url}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{color}
\usepackage{hyperref}
\usepackage{fancyhdr}
\usepackage[titles]{tocloft}
\usepackage{pdfpages}
\hypersetup{
    colorlinks=true, %set true if you want colored links
    linktoc=all,     %set to all if you want both sections and subsections linked
    linkcolor=blue,  %choose some color if you want links to stand out
}
\usepackage[top=20mm, bottom=20mm, left=30mm, right=15mm]{geometry}
\newfontfamily{\armenianfont}{DejaVu Serif}
\newfontfamily{\armenianfonttt}{DejaVu Sans Mono}
\newfontfamily{\armenianmathfont}{DejaVu Serif}
\ExplSyntaxOn
\DeclareSymbolFont{armenianletters}{\g_fontspec_encoding_tl}{\l_fontspec_family_tl}{m}{it}
\int_step_inline:nnnn { "531 } { 1 } { "556 }
{
\Umathcode #1 = "0 \symarmenianletters #1 % low level call
}
\int_step_inline:nnnn { "561 } { 1 } { "587 }
{
\Umathcode #1 = "0 \symarmenianletters #1
}
\ExplSyntaxOff
\setmainlanguage{armenian}
\renewcommand*\contentsname{Բովանդակություն}
\author{Բաբկեն Վարդանյան}
\title{Մեքենայական լեզվով ծրագրերի պաշտպանությունը վերծանումից}
\urlstyle{tt}

\definecolor{bluekeywords}{rgb}{0,0,1}
\definecolor{greencomments}{rgb}{0,0.5,0}
\definecolor{redstrings}{rgb}{0.64,0.08,0.08}
\definecolor{xmlcomments}{rgb}{0.5,0.5,0.5}
\definecolor{types}{rgb}{0.17,0.57,0.68}
\lstset{language=C++,
  frame=bt,
  showtabs=false,
  tabsize=4,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  escapeinside={(*@}{@*)},
  commentstyle=\color{greencomments},
  keywordstyle=\color{bluekeywords},
  stringstyle=\color{redstrings},
  basicstyle=\ttfamily
}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[R]{\thepage}

\renewcommand{\figurename}{Նկար}


\begin{document}
\pagenumbering{arabic}
\setcounter{page}{5}
%\pagenumbering{gobble}
Կցանկանայի խորին երախտագիտությունս հայտնել իմ ղեկավար տ․գ․թ․, դոցենտ
Ռոբերտ Հակոբյանին (ՀՊՃՀ), ով ինձ աջակցել և խրախուսել է այս աշխատանքի
ժամանակ։

\hfill \hfill Բաբկեն Վարդանյան

\newpage

\tableofcontents

\newpage
\section{Ներածություն}
\begin{sloppypar}
\subsection{Տեխնիկական բառարան}

\begin{tabular}{rl}
անցնել վրայով&parse \\
անցնել&sweep \\
ապօրինի օգտագործում&piracy \\
բազային&base \\
բազմություն&set \\
բաժին&section \\
բացառություն&exception \\
բացել&uncompress \\
բեռնիչ&loader \\
գլխամաս&header \\
գծային անցում&linear sweep \\
դասավորում&alignment \\
երկակի բառ&dword \\
թիրախ, սպառնալիք&target \\
ժառանգված ծրագրեր&legacy software \\
իրականացում&implementation \\
լինկեր&linker \\
խառնել&shuffle \\
կամայական&optional \\
կատարվող ֆայլ&executable \\
կարգաբերիչ&debugger \\
կարգաբերում&debug \\
կոթ&handle \\
հակառակորդ&attacker \\
հատկություններ&characteristics \\
հետևում&traversal \\
ձևափոխել&modify \\
%մաս&stub \\
միջոց, գործողություն&technique \\
ներմուծում&import \\
չարամիտ&malicious \\
պատկեր&image \\
պրոցես&thread \\
սեղմող ծրագիր&packer \\
սկզբնական կոդ&source code \\
սպասարկում&maintenance \\
ստորագրություն&signature \\
վերադասավորում&permutation \\
վերատեղավորել&relocate \\
վերլուծություն&analysis \\
վերծանում&reverse engineering \\
վնասաբեր ծրագրեր&malware \\
տվյալների դիրեկտորիա&data directory \\
փոփոխություններ&tampering \\
\end{tabular}

\begin{tabular}{rl}
քանդել&disassemble \\
օբֆուսկացիա&obfuscation \\
օրինաչափություն&pattern \\
\end{tabular}

\subsection{Ներածություն}
Համակարգչային ծրագրերի օգտագործումը դարձել է մեր կյանքի անկյունաքարերից մեկը։
Ինտերնետի և համակարգչային ցանցերի լայն տարածման հետ նշանակալից առաջընթաց է
գրանցվել ծրագրերի և թվային այլ բովանդակության տարածման գործում։

Ծրագրերը կարող են լինել բավականին թանկարժեք, և այդ պատճառով ծրագրերի ապօրինի
օգտագործումը լայն տարածում է ստացել։ Սրա հետ մեկտեղ կա աճող պահանջարկ այն
մեթոդների նկատմամբ, որոնք կարող են կանխարգելել ծրագրերի վերլուծությունը և
փոփոխությունները այլ ծրագրերի օգնությամբ օգտագործողների կողմից։

Այսօր ծրագրային ապահովման մեծամասնությունը վճարովի է, և կարիք ունի
պաշտպանության այնպիսի սպառնալիքների դեմ, ինչպիսիք են վերծանումը,
փոփոխությունները և ապօրինի օգտագործումը։ Չարամիտ օգտագործողների դեմ պաշտպանությունը
դժվար խնդիր է, քանի որ օգտագործողը բացարձակ վերահսկողության ունի իր համակարգչի
նկատմամբ։
Այնուամենայնիվ, ծրագրերի սեփականատերերը կարողանում են զինվել նմանօրինակ
սպառնալիքների դեմ։

Ծրագրային ապահովում ստեղծող ընկերության տեսանկյունից շատ ցանկալի է որ
ընկերության արտադրանքը դժվար լինի վերծանել և ապօրինի օգտագործել։
Առաջին հայացքից թվում է թե ծրագրերը դժվար վերծանվող դարձնելը հակասում է այն
գաղափարին, որ ծրագիրի դիզայնը պետք է հեշտորեն հնանարավոր լինի
վերականգնել՝ հետագայում ծրագրի սպասարկման և գնահատման համար։
Այդ պատճառով, ծրագրային ապահովում արտադրողները սովորաբար չեն կիրառում
հակա֊վերծանման փոփոխություններ ծրագրերի կատարվող տարբերակների վրա քանի դեռ
այն փաթեթավորված չէ օգտագործողներին առաքման համար։

Սովորաբար ծրագրեր արտադրողները կներդնեն ժամանակ ծրագիրը դժվար վերծանվող
դարձնելու համար միայն եթե նրանում կան հատկապես հետաքրքիր ալգորիթմներ,
որոնք այդ արտադրանքը առանձնացնում են մրցակիցներից։

Ծրագիրը դժվար վերծանվող դարձնելը և ապօրինի օգտագործումից պաշտպանելը հաճախ
շարժվող թիրախ է, և ծրագիրը մշակողի կողմից պահանջում է հատուկ հմտություններ և
գիտելիքներ։

Այն ծրագրավորողները, ովքեր հնարավորություն են ունեցել օգտագործել հակավերծանման
գործիքներ և հմտություններ, կարող են ավելի լավ դիրքում լինել օգնել իրենց գործատուին
կամ իրենց պաշտպանել մտավոր սեփականությունը։ Ինչպես ասում են, «Գողին հաղթելու
համար պետք է մտածել նրա նման»։

Վիրուսներ կամ այլ վնասակար ծրագրեր վերծանելով ծրագրավորողները կարող են
անմիջապես սովորել դրանց ներքին կառուցվածքը և առաջին դեմքից դիտել թե
ինչպես են խոցելիությունները օգտագործվում համակարգչային ծրագրերում։

Այս աշխատանքը քննարկում է կոդի օբֆուսկացիայի եղանակներ՝ ծրագրերը
վերլուծությունից և անցանկալի փոփոխություններից պաշտպանության նպատակով։
Ծրագրերի օբֆուսկացիան կոդը ավելի դժվար վերլուծվող է դարձնում։
Անուղղակիորեն, դա նաև նպաստում է չարամիտ փոփոխությունների դեմ ծրագրի
պաշտպանությանը։ Սա բխում է այն փաստից, որ հակառակորդը պետք է
հասկանա ծրագիրը, նախքան համապատասխան փոփոխություններ կատարելը։ 
Ծրագրերի վերլուծությունը դժվարացնող մեթոդներից բացի կարելի է ավելացնել
մեթոդներ, որոնք նաև դժվարացնում են փոփոխությունները։

Ստեղծված ծրագիրը կարելի է անմիջապես օգտագործել գործնական կիրառական
համակարգչային ապահովումը պաշտպանելու նպատակով։ Այս մեթոդի կիրառումը
չի անդրադառնում ծրագրի այլ մասերի վրա, այդ պատճառով այն կարելի է
օգտագործել ցանկացած այլ պաշտպանիչ համակարգի հետ համատեղ։

\subsection{Մեքենայական ծրագիր}
Մեքենայական կոդը կամ մեքենայական լեզուն հրահանգների և տվյալների համակարգ է,
որը ուղղակիորեն հասկանալի է համակարգչի պրոցեսորի կողմից։

Ծրագրային ապահովման կատարվող տեսքով ներկայացումը, այլապես հայտնի որպես
մեքենայական կոդ, որպես կանոն արդյունք է բարձր մակարդակի մի
լեզվով գրված ծրագրի թարգմանության օբյեկտային ֆայլի՝ թարգմանիչ ծրագրի միջոցով։
Օբյեկտային ֆայլը պարունակում է համակարգին առանձնահատուկ մեքենայական հրամաններ,
և այն դառնում է կատարվող ֆայլ լինկեր կոչվող գործիքի միջոցով, որը վերլուծում է
օբյեկտային ֆայլի արտաքին կախվածությունները, ինչպես օրինակ համակարգային
գրադարանները։

Ի տարբերություն բարձր մակարդակի լեզուների՝ կան նաև ցածր մակարդակի լեզուներ,
որոնք համարվում են բարձր մակարդակի համակարգչի պրոցեսորի կողմից,
քանի որ այդ լեզվուների շարահյուսությունը դեռևս պրոցեսորի հրահանգների տեքստային
ներկայացում է։ Օրինակ՝ ասեմբլեր լեզուն մի լեզու է, որը օգտագործում է
մարդու կողմից ընկալելի հրամաններ մեքենայական լեզվի հրահանգները ներկայացնելու
համար։ Ասեմբլերը նույնպես պետք է թարգմանվի օբյեկտային ֆայլի և դառնա կատարվող
ֆայլ լինկերի կողմից։

Ի տարբերություն դրա՝ ասեմբլեր կոդից մեքենայական կոդի թարգմանությունը կատարվում
է ասեմբլերի միջոցով, և ոչ թե կոմպիլյատորի, ինչն արտացոլում է ասեմբլեր լեզվի
շարահյուսության մեքենայկան կոդին մոտիկությունը։

Կոմպիլյատորները թարգմանում են բարձր և ցածր մակարդակի լեզուներով գրված ծրագրերը
մեքենայական լեզվի հետևյալ պատճառով՝
Պրոցեսորները հասկանում են միայն մեքենայական հրամաններ, եթե պրոցեսորը
դինամիկորեն թարգմաներ բարձր մակարդակր լեզվի հրամանները մեքենայական
հրահանգների, դա կսպառեր զգալի պրոցեսորի ժամանակ, և մի պրոցեսոր որը
կարող է դինամիկորեն թարգմանել բազմաթիվ բարձր մակարդակի լեզուներ
մեքենայական կոդր կլիներ չափազանց բարդ, թանկ և դժվար սպասարկվող․
պատկերացրեք որ պետք է թարմացնել միկրոպրոցեսորի ներքին կոդը ամեն անգամ
մի սխալ է ուղղվում կամ նոր ֆունկցիոնալություն է ավելացվում C++
լեզվում։

\section{Խնդրի դրվածքը}
Տեխնոլոգիական ոլորտում առաջընթացը հանգեցրել է ավտոմատացված կարգաբերման
գործիքների պարզ օգտագործման, ինչը կարող է չափազանց օգտակար լինել կոդում
սխալներ հայտնաբերելիս։ Սակայն չարամիտ հակառակորդը կարող է օգտագործել
նույն գործիքները։ Անվտանգ ծրագրեր մշակելը և դրանք անվտանգ պահելը օրեցօր
դառնում է ավելի դժվար։ Հենց նույն հեշտ օգտագործվող կարգաբերիչ ծրագրերը
կարող են օգտագործվել ծրագրերում ներդված անվտանգության համակարգերը
շրջանցելու համար։ Թեև կատարվող ֆայլում փոփոխություններ հայնտաբերելը
հնարավոր է, նույնքան հեշտ չէ կանխել այդ փոփոխությունների կատարումը
առաջին հերթին։ Փոփոխությունները դժվար դարձնելու եղանակներից մեկն է
հակառակորդի համար վերլուծության փուլի դժվարացումը։

Առաջին հերթին մենք կներկայացնենք ծրագրերի վերծանման և պաշտպանության մեթոդների
համապարփակ նկարագիր։ Երկու դեպքում էլ հստակ տարբերություն է դրվում ստատիկ և
դինամիկ գրոհների միջև։

Այս թեզը ներկայացնում է օբֆուսկացիայի մի մեթոդ, երբ ծրագրի վերլուծությունը
չարամիտ օգտագործողի (հակառակորդի) կողմից դժվարացվում է՝ PE ֆայլի գլխամասում
սեկցիաների անունների խառնման միջոցով։ Առաջարկվող մեթոդում սեկցիաների
անունները խառնվում են հակառակորդին շփոթության մեջ գցելու նպատակով։

Եթե հակառակորդը ամբողջովին հասկանում է այս մեթոդը, նույնիսկ այդ
դեպքում նրանից կպահանջվի որոշ ժամանակ՝ յուրաքանչյուր սեկցիայի դերը
հասկանալու համար, քանզի սեկցիաների անունները ամեն անգամ ընտրվում են
պատահականորեն։

Որպեսզի վերլուծությունը հաջող լինի, հակառակորդը պետք է նայի յուրաքանչյուր
սեկցիայի բնութագրերին և ուսումնասիրի դրանց պարունակությունը, որպեսզի
հասկանա դրանց նշանակությունը, ինչը հակառակորդից պահանջում է հավելյալ ժամանակ։

Ներկայացվող մեթոդը կարող է հեշտորեն ավտոմատացվել, և չի պահանջում ոչ մի
լրացուցիչ մուտքագրում կամ կարգաբերում ծրագրերի հեղինակների կողմից։
Այս մեթոդը չունի 4.4 գլխում թվարկված բացասական էֆֆեկտներից ոչ մեկը։

\section{Վերծանում}
Գոյություն ունեն ծրագրային ապահովման 3 հիմնական սպառնալիքներ՝ վերծանումը,
փոփոխությունները և ապօրինի օգտագործումը։

\begin{itemize}
\item Ծրագրերի վերծանումը դա ծրագրային համակարգի ուսումնասիրության
	գործընթացն է, կամ ամբողջությամբ, կամ մասնակիորեն՝ նախագծման և
	իրականացման մասին տեղեկություններ ստանալու նպատակով՝ սկզբնական կոդի
	բացակայության պարագայում։ Այն ներկայացնում է ծրագրերի ներքին աշխատանքը
	դիտելու միջոցներ։
\item Փոփոխությունները ընդգրկում է ծրագրին միջամտելու եղանակները։
	Այն ծրագրի որոշ մասերի փոփոխությունն է՝ հակառակորդի կարիքներին բավարարելու
	համար։
\item Ապօրինի օգտագործումը դա ծրագրային ապահովման չարտօնված կիրառումն է
	վերջնական օգտագործողների կողմից։
\end{itemize}

Վերծանումը կատարվում է հետևյալ նպատակներով՝
\begin{enumerate}
\item Վավերականության ստուգումների շրջանցման միջոցով ծրագրի ապօրինի
	պատճեների ստեղծումը:
\item Վիրուսների և այլ վնասաբեր ծրագրերի ուսումնասիրություն՝ անվտանգության
	նպատակներով։
\item Նույն ոլորտում աշխատող ընկերությունների դեմ մրցակցային հետախուզություն՝
	ծրագրում պարունակվող ալգորիթմներ վերականգնելու միջոցով։
\item Ժառանգված ծրագրերի սպասարկում և դոկումենտացիայի ստեղծում։
\item Ստուգում, որ իրականացումը համապատասխանում է նախագծին։
\end{enumerate}

Վերծանումը բաղկացած է 2 քայլից՝ վերլուծություն և փոփոխություններ։

\subsection{Թիրախի վերլուծություն}
Վերլուծության ընթացքում հակառակորդը փորձում է բացահայտել ալգորիթմներ, գաղտնի
բանալիներ և այլ կարևոր ինֆորմացիա որը կարող է նրան հետագայում օգնել
հարձակման փուլում։

Սովորաբար նման գործողությունը ենթադրում է հետևյալ քայլերի ներգրավում՝
Առաջին հերթին հակառակորդը քանդում է ծրագիրը և փորձում է հասկանալ ստացված
ասեմբլեր ծրագիրը։ Սակայն հսկայական քանակությամբ աշխատանք և ժամանակ է
պահանջվում մեծ ծավալով ծրագիրը ամբողջությամբ հասկանալու համար, ինչը
իրատեսական չէ։ Հետևաբար հակառակորդը սահմանափակում է դիտարկվող մասը
(այն մասը որը թվում է կապված է գաղտնի տեղեկատվության հետ), և փորձում է
հասկանալ միայն այդ մասը։ Սահմանափակումը և այդ մասի հասկանալու գործընթացը
կրկնվում են մինչև ձեռք է բերվում հարկավոր գաղտնի տեղեությունները։

Վերլուծությունը կարող է լինել ստատիկ կամ դինամիկ։

\subsubsection{Ստատիկ վերլուծություն}
Ստատիկ վերլուծությունը կատարվում է ոչ կատարվող կոդի նկատմամբ։ Այս դեպքում
հակառակորդը օգտագործում է դիսասեմբլեր կոչվող գործիքներ, որոնք թարգմանում են
ֆայլում եղած մեքենայական կոդը մարդու համար ընթեռնելի ասեմբլեր լեզվի։ Այս
մեթոդը կոչվում է «գծային անցում»։ Այս մեթոդի օրինակ է objdump կոչվող ծրագրիը
GNU binutils հավաքածուից։

Այս մեթոդի խնդիրն այն է, որ այն կարելի է հեշտորեն շփոթեցնել օգտագործելով
պարզ հակակարգաբերման մեթոդներ ինչպես օրինակ «անպետք բայտի ներմուծում», որը
կարող է դիսասեմբլերին ճանապարհից շեղել, քանի որ այն հաշվի չի առնում
ծրագրի կատարման հոսքի ուղղությունը։

\subsubsection{Դինամիկ վերլուծություն}
Դինամիկ վերլուծության ընթացքում օգտագործվում են կարգաբերիչ կոչվող ծրագրեր։
Ամենահայտնի կարգաբերիչներն են IDA Pro և OllyDBG֊ը։ Դինամիկ վերլուծության
ընթացքում օգտագործվում է «ռեկուրսիվ հետևում» կոչվող միջոցը, որը հաշվի է
առնում ծրագրի կատարման հոսքը։ Սակայն քանի որ որոշ ճյուղերի աշխատանքը
կախված է օգտագործողի մուտքից, սովորաբար ոչ բոլոր նպատակային հասցեներն են
ստատիկորեն ստացվում և վերծանվում։ Դեբագգերները վերլուծում են նպատակային
կոդի ղեկավարման հոսքը և նաև հակառակորդին հնարավորություն են տալիս
դինամիկորեն դիտել և փոփոխել հիշողության և պրոցեսորի ռեգիստրների
պարունակությունը հենց ծրագրի կատարման ժամանակ։

Այս մեթոդը շատ ավելի դանդաղ է քան ստատիկ վերլուծությունը, քանի որ
դեբագերը պետք է անցնի ամեն հնարավոր կատարման ուղղով։ Այս մեթոդը
կարող է նաև շփոթեցվել բազմաթիվ հակակարգաբերման միջոցներով, և
չի երաշխավորում ճշգրիտ արդյունքներ։

\subsection{Փոփոխություններ}
Սովորաբար սկզբում անհրաժեշտ է ծրագրի ներքինի մասին ինֆորմացիա մինչև հնարավոր
լինի ծրագրի մեջ փոփոխություններ կատարել։ Հետևաբար փոփոխություն կատարելու
հարձակումներին սովորաբար նախորդում են մի քանի վերծանման գործողություններ։
Եվ երբ մի անգամ բավարար վերլուծություն է կատարվել, հակառակորդը կփորձի
փոփոխել ծրագիրը՝ իր նպատակներին համապատասխան։ Հաքերը կարող է ծրագիրը
հասանելի դարձնել բոլորին, նույնիսկ առանց վավերականացման կամ ծրագրի օգտագործման
իրավունքների։ Վերլուծության նման, փոփոխությունները նույնպես կարող են
լինել ստատիկ կամ դինամիկ, այսինքն ստատիկ կամ կատարվող կոդի նկատմամբ։

\subsubsection{Ստատիկ փոփոխություններ}
Ստատիկ փոփոխությունների մեթոդները ձևափոխում են ստատիկ երկուական պատկեր։
Ավտոմատացված հարձակումը՝ բաղկացած crack-ի բեռնումից և այն պահպանված
երկուական ֆայլի վրա կիրառելուց, սովորաբար համարվում է ստատիկ փոփոխության
հարձակում, եթե ենթադրենք որ կոդը չի բեռնվում հիշողություն և փոփոխությունների
ենթարկվում այնտեղ։

\subsubsection{Դինամիկ փոփոխություններ}
Դինամիկ փոփոխության միջոցները ձևափոխում են ծրագիրը աշխատանքի ժամանակ։
Նախ, կարգաբերիչները բեռնում են կոդը հիշողություն։ Երբ հրամանները քայլ առ քայլ
կատարվում են, հնարավոր է ձևափոխել բեռնված ծրագրի կոդը, տվյալները, կամ վիճակը
(օր՝ ռեգիստրների պարունակությունը)։ Դինամիկ փոփոխությունների հարձակումը
սովորաբար իրականացվում է «ձեռքով» և ընդհանրություններ ունի ծրագրերի
կարգաբերման հետ։

\section{Պաշտպանության միջոցներ}
Ծրագրերի պաշտպանության անհրաժեշտություն ծագել է տարբեր ոլորտներում։ Տվյալների
անվտանգությունը ընդգրկում է տվյալների գաղտնիությունը և ամբողջականությունը,
որպես կանոն հաղորդման և պահպանման ժամանակ։ Ծրագրերի անվտանգությունը
ուսումնասիրում է ծրագրերի պաշտպանությունը վերլուծության, փոփոխությունների և
շահագործման այլ միջոցների դեմ։ Մենք կկենտրոնանանք միայն ծրագրերի անվտանգության
վրա։

Մենք հետևում ենք այն տեսակետին, որ ծրագրերը բաղկացած են ֆունկցիոնալ կոդից
(որը հենց փաստացի ծրագիրն է), որին ավելացված է այլ կոդ (անվտանգության կոդ)։
Հաճախ մեկ կամ մի քանի բաղադրիչներ անհրաժեշտ են ծրագրի նորմալ աշխատանքի
համար: Ծրագրերի պաշտպանության մեթոդները ծառայում են որպես սոսինձ այս
անհրաժեշտ բաղադրիչները կոդի մնացած մասին միացնելու համար։ Այս ամենը միասին
դառնում է մեկ միասնական ծրագիր, մինչդեռ առանց պաշտպանության այս տեսակի
կոդը հեշտությամբ հնարավոր կլիներ նույնականացնել, մեկուսացնել և հարձակման
ենթարկել։

Կան պաշտպանության տարբեր եղանակներ, բայց նրանցից ոչ մեկը չի երաշխավորում
100\%֊անոց պաշտպանություն, այլ միայն ավելացնում է հարձակման համար
անհրաժեշտ ժամանակը։

Ծրագրային ապահովումը կարող է պաշտպանվել մի քանի սկզբունքներով՝

\begin{enumerate}
\item Ջրանշում
\item Ծրագիրը որպես ծառայություն
\item Օբֆուսկացիա
\end{enumerate}

Մենք կկենտրոնանանք միայն օբֆուսկացիայի վրա։

\subsection{Օբֆուսկացիա}
Օբֆուսկացիան ծրագրային փոփոխությունների շարք է, որը ծրագրի կոդը և/կամ
ծրագրի կատարումը դարձնում է դժվար վերլուծվող։ Օբֆուսկացիան պաշտպանության
ամենատարածված մեթոդն է։ Այն նախատեսված է հակառակորդին շփոթեցնելու,
կարգաբերիչների աշխատանքը դժվարացնելու համար, և այն ասեմբլեր կոդը դարձնում է
ավելի քիչ հասկանալի՝ ձևափոխելով ծրագիրի գործողությունները, բայց միաժամանակ
պահպանելով ալգորիթմները անփոփոխ։

Օբֆուսկացիայի սահմանումը հետևյալն է՝ ենթադրենք որ P ծրագրային կոդը դառնում է
P' որոշ փոփոխություններից հետո։ $P \rightarrow P'$ ձևափոխությունը կոչվում է
օբֆուսկացնող ձևափոխություն եթե P և P'֊ը նույնանման վարքագիծ են դրսևորում։

\subsection{Պաշտպանություն ստատիկ հարձակումների դեմ}
\subsubsection{Պոլիմորֆիզմ}
	Պոլիմորֆիկ կոդը դա կոդ է, որը ձևափոխվում է՝ պահպանելով բուն ալգորիթմը
	անփոփոխ։ Այս մեթոդը երբեմն օգտագործվում է համակարգչայաին վիրուսների
	և որդերի կողմից՝ իրենց ներկայությունը թաքցնելու
	համար։ Հակավիրուսային ծրագրերի և ներխուժման հայտնաբերման համակարգերի
	մեծ մասը փորձում է հայտնաբերել վնասակար կոդը փնտրելով համակարգչի ֆայլերի և
	համակարգչային ցանցով փոխանցվող տվյալների փաթեթների մեջ։ Եթե անվտանգության
	համակարգը հայտնաբերում է նմուշներ, որոնք համապատասխանում են հայտնի
	համակարգչային վիրուսի կամ որդի, այն կարտարում է համապատասխան քայլեր
	սպառնալիքը չեզոքացնելու համար։ Պոլիմորֆիկ ալգորիթմները դժվարացնում են
	նման համակարգերի համար վտանգավոր կոդի հայտնաբերումը, քանի որ այն
	մշտապես ձևափոխվում է։

\subsubsection{Ինքնաձևափոխվող կոդ}
	Ինքնաձևափոխվող կոդը դա կոդ է, որը նպատակային կերպով ինքն իրեն ձևափոխում է։

	Այսօր ինքնաձևափոխվող կոդը օգտագործվում է այնպիսի ծրագրերի կողմից,
	որոնք չեն ցանկանում բացահայտել իրենց ներկայությունը, ինչպես վիրուսները։
	Վիրուսները, որոնք օգտագործում են ինքնաձևափոխվող կոդ, հաճախ օգտագործում են
	նաև պոլիմորֆիկ կոդ։ Պոլիմորֆիկ վիրուսները հաճախ կոչվում են պարզագույն
	ինքնաձևափոխվող կոդեր։ Կատարվող կոդի ձևափոխությունը օգտագործվում է նաև
	որոշ տեսակի հարձակումներում, ինչպես բուֆերի գերլցումը։

\subsubsection{Գաղտնագրություն}
	Պաշտպանության պարզագույն ձևերից մեկը տվյալների գաղտնագրումն է։
	Երբ տվյալները բացահայտ կերպով պահվում են տվյալների սեկցիայում, այն կարող է
	որոշ ձևով հուշել հակառակորդին ծրագրում կատարվող գործողությունների մասին։

	Գաղտնագրումը ինֆորմացիայի անհասկանալի դարձնելու գործընթացն է, որը այն
	դարձնում է անհասանելի առանց հատուկ գիտելիքների։ Գաղտնագրումը կարող է
	օգտագործվել գաղտնիությունն ապահովելու համար, բայց այլ մեթոդներ նույնպես
	անհրաժեշտ են ամբողջականությունը և վավերականությունը ստուգելու համար։
	Գաղտնագրումը կամ ծրագրային կոդի օբֆուսկացիան օգտագործվում է ծրագրերի
	պատճենումից պաշտպանության մեջ` վերծանման, ծրագրերի ապօրինի վերլուծության,
	և ապօրինի օգտագործման մեջ։ Այն օգտագործվում է տարբեր գաղտնագրող կամ
	օբֆուսկացնող ծրագրերի մեջ։

	Գաղտնագրությունը կոդի պոլիմորֆիզմի հասնելու առավել հաճախ օգտագործվող
	մեթոդն է։ Սակայն կոդի ոչ ամբողջ մասն է հնարավոր գաղտնագրել, քանի որ այդ
	դեպքում այն բոլորովին անպիտան կդառնա։ Որոշ մաս թողնվում է չգաղտնագրված
	և օգտագործվում է գաղտնագրված ծրագրի նախնական թողարկման նպատակով։
	Հակավիրուսային ծրագրերը թիրախ են դրառնում կոդի այս փոքր չգաղտնագրված մասը։
	Չարամիտ ծրագրավորողները ձգտում են պաշտպանել իրենց պոլիմորֆիկ կոդը այս
	ռազմավարությունից կրկին գրելով չգաղտնագրված գաղտնագրող մասը ամեն անգամ
	բազմացման ժամանակ։ Հակավիրուսային ծրագրերում օգտագործում են նմուշների բարդ
	վերլուծության եղանակներ՝ վերծանման համակարգում տարբեր ձևափոխությունների
	նմանությունները հայտնաբերելու հայտնաբերելու համար` հուսալի կերպով նման
	վնասաբեր ծրագրեր հայտնաբերելու հույսով։
	
\subsubsection{Մետամորֆիզմ}
	Մետամորֆիկ կոդը դա կոդ է որը կարող է վերածրագրավորել ինքն իրեն։ Հաճախ
	այն անում է դա իր սեփական կոդը ժամանակավոր ներկայացման մեջ թարգմանելով,
	և հետո հետ դեպի նորմալ կոդը։ Սա օգտագործվում է որոշ վիրուսների կողմից, երբ
	նրանք պատրաստվում են նոր ֆայլեր վարակել, և արդյունքն այն է, որ նրանց
	երեխանորը երբեք իրենց նման չեն ստացվի։ Այս մեթոդը օգտագործող վիրուսները
	որոնք օգտագործում են այս մեթոդը անում են սա հակավիրուսային ծրագրերի
	նմուշային ճանաչումից խուսափելու նպատակով․ իրական ալգորիթմը չի փոխվում,
	բայց մնացած ամեն ինչ հնարավոր է փոխվի։

	Մետամորֆիկ կոդը ավելի եֆեկտիվ է քան պոլիմորֆիկ կոդը։ Սա այն պատճառով է,
	որ հակավիրուսային ծրագրերի մեծամասնությունը փորձում են փնտրել հայտնի
	վիրուսային կոդ նույնիսկ կոդի կատարման ընթացքում։

	Մետամորֆիկ կոդը կարող է նաև նշանակել որ վիրուսը կարող է վարակել
	կատարվող ֆայլեր 2 կամ ավել օպերացիոն համակարգերից (ինչպես օրինակ Windows և
	Լինուքս) կամ նույնիսկ տարբեր ճարտարապետության համակարգիչներ։ Հաճախ
	վիրուսը սա անում է կրելով մի քանի այլ վիրուսներ իր մեջ, այնպես որ
	իրականում այն դառնում է մի քանի վիրուսներ, որոնք միավորված են մեկի մեջ,
	այսպես կոչված «սուպերվիրուս»:

\subsubsection{Սեղմող ծրագրեր}
	Այս ծրագրերը ավելի հաճախ օգտագործվում են կատարվող ֆայլերը փոքրացնելու
	նպատակով, սակայն հաճախ օգտագործվում են նաև ավելի քիչ հմուտ հակառակորդների
	համար վերծանումը դժվարացնելու համար։ Ներկայումը ամենատարածված սեղմող
	ծրագիրը UPX֊ն է։

	Կատարվող ֆայլերի սեղմումը դա կատարվող ֆայլերի սեղմման և վերծանող մասի
	ավելացման պրոցեսն է, որը պատասխանատու է կատարվող ֆայլի վերծանման և նրա
	կատարման սկսման համար։ Վերծանման մասը ինքնուրույն կատարվող ֆայլ է, որը
	սեղմված և չսեղմված կատարվող ֆայլերի միջը տարբերությունը դարձնում է
	աննշմարելի սովորական օգտագործողի համար, քանի որ նրանք ոչ մի հավելյալ
	գործողություններ չեն կատարում ծրագրի կարտարման սկսման համար։

	Երբ ֆայլը կատարվում է, վերծանող մասը բացում է սկզբնական կատարվող կոդը և
	ղեկավարումը փոխանցում է դրան։ Այս դեպքում կատարվող գործողությունները
	նույնն են ինչ սկզբնական չսեղմված կատարվող ֆայլի կատարման ժամանակ։
	Սեղմված կատարվող ֆայլը պահանջում է՝
	\begin{itemize}
	\item Ավելի քիչ պահպանման համար անհրաժեշտ տարածք ֆայլային համակարգում
	\item Ավելի քիչ ժամանակ տվյալները ֆայլային համակարգից հիշողություն
		փոխանցելու համար
	\item Ավելի շատ ժամանակ տվյալները բացելու համար մինչև կատարման սկիզբը քան
		չսեղմված սկզբնական ֆայլը
	\end{itemize}

\subsubsection{Անպետք բայտերի ներմուծում}
	Սա պաշտպանության ամենահասարակ մեթոդներից է, այն ստատիկ վերծանումը
	դարձնում է ավելի դժվար քանի որ դիսասեմբլերները չեն կարողանում
	տարբերել անպետք բայտերը և պրոցեսորի հրամանները։ Սա հեշտությամբ
	կատարվում է ներդրված ասեմբլեր բլոկների միջոցով։ Այս մեթոդը ոչինչ
	չի անում ռեկուրսիվ դեբագերների դեմ, որոնք նաև նայում են ծրագրի
	կատարման ուղուն։

\subsection{Պաշտպանություն դինամիկ հարձակումներից}

\subsubsection{Պաշտպանիչներ}
Կատարվող ֆայլի պաշտպանիչը իրականում պարզագույն սեղմող ծրագրի ածանցյալն է,
ինչը նշանակում է որ պաշտպանիչը մեծամասամբ կամ նույնիսկ ամբողջությամբ
շեշտը դնում է վերծանումից պաշտպանության վրա ի տարբերություն պարզ սեղմող
ծրագրի։

Սակայն սա բերում է որոշ կարևոր թերություններ տարածվող ծրագրի համար՝
առաջին հերթին նրա չափը։ Սեղմող ծրագիրը նպատակ ունի ինչքան հնարավոր է փոքրացնել
կատարվող ֆայլի չափը, իսկ պաշտպանիչը հաճախ ավելացնում է այնքան շատ կոդ
փորձելով պաշտպանել վերծանումից, որ արդյունքի չափը կարող է զգալիորեն
ավելանալ։ Կան օրինակներ երբ չափը մեծանում է մոտ 600\%, երբ պարզագույն սեղմող
ծրագիրը չափը փոքրացնում է մոտ 30\%֊ի սկզբնականի հետ համեմատած։

\subsubsection{Կոդի կատարման ուղղության օբֆուսկացիա}
Այս մեթոդը ներառում է՝
\begin{itemize}
\item Բարձր մակարդակի օբֆուսկացիա
\item Հրամանների հերթականության պատահականեցում
\item Կոդի նոր բլոկների ներմուծում, որոնք չեն ազդում ծրագրի կատարման վրա
\item Ներտողային ֆունկցիաների օգտագործում իրական ֆունկցիաների կանչի փոխարեն
\item Կրկնօրինակ ֆունկցիաների ներմուծում, որոնք կատարում են նույն
	գործողությունները տարբեր ալգորիթմներով
\item Ցիկլի մարմնի կրկնօրինակում
\item Ճյուղավորման ֆունկցիաներ՝\\
	Թռիչքների փոխարեն կանչվում է ֆունկցիա որի ժամանակ հենց կատարվում է
	թռիչքը, բայց այն երբեք հետ չի վերադառնում, ի տարբերություն սովորական
	ֆունկցիայի կանչի։
\end{itemize}

\subsubsection{Համակարգում կարգաբերիչների առկայության ստուգում}
Եթե ծրագիրը նկատում է համակարգում աշխատող կարգաբերիչ ծրագրի պրոցես, կամ
կոշտ սկավառակի վրա, այն կարող է կատարել համապատասխան գործողություններ
հակառակորդին շփոթեցնելու համար։ Կարգաբերիչների առկայությունը կարող է
ստուգվել պրոցեսորի կարգաբերման ռեգիստրների պարունակությունը դիտելով
կամ կոդի սեգմենտում փոփոխություններ հայտնաբելու եղանակով (int 3 հրահանգի
ներմուծում).

Այս մեթոդի մի այլ օրինակ է Win32 API֊ի IsDebuggerPresent() ֆունկցիան, որը
որոշում է արդյոք կանչող ծրագիրը կարգաբերվում է օգտագործողի ռեժիմում աշխատող
կարգաբերիչով։

\subsubsection{Ծրագրի մասերի թաքցնում}
Որոշ ծրագրերի հեղինակներ որոշում են թաքցնել իրենց կոդի որոշ մասը, օրինակ
արտաքին սարքերում կամ վեբ սերվերներում։

\subsubsection{Դինամիկ ինքնաձևափոխվող կոդ}
Այս մեթոդի ժամանակ ձևափոխությունները կատարվում են կոդի սեգմենտում այդ
կոդի կատարման ժամանակ։ Սա հաճախ օգտագործվում է վիրուսներում։

\subsubsection{Զուգահեռականացում}
Գծային ծրագրերում հեշտ է կռահել ծրագրի կատարման ուղին։ Այս մեթոդի օգտագործման
ժամանակ ծրագիրը բաժանվում է մի քանի իրարից անկախ մասերի։ Հետո այս մասերը
կատարվում են առանձին մի քանի տարբեր պրոցեսներում կամ thread-ներում։ Սա
էքսպոնենտային ձևով մեծացնում է հնարավոր կատարման ուղիները և կոդի վերլուծման
համար անհրաժեշտ ժամանակը։

\subsubsection{Վիրտուալացում}
Վիրտուալացման ժամանակ ծրագրի կատարումը կազմակերպվում է սեփական վիրտուալ
մեքենայում։

\subsection{Բացասական ազդեցություններ}
Երբ ընտրվում է պաշտպանության մեթոդ, ծրագրի հեղինակը պետք է հաշվի առնի, որ
այս մեթոդներից շատերը ծրագրի վրա թողնում են բացասական ազդեցություն՝
\begin{enumerate}
\item Ծրագրի սպասարկման համար պահանջում են լրացուցիչ ժամանակային և ֆինանսական
	ռեսուրսներ
\item Բարդացնում են կարգաբերումը
\item Դանդաղեցնում են ծրագիրը
\item Մեծացնում են կատարվող ֆայլի չափը
\item Դժվարացնում են ծրագրի կարդալը և հասկանալը
\item Պրոյեկտի արժեքի ավելի քիչ մասն է ներդրվում հաճախորդի համար արժեք
	ավելացնելու նպատակով
\item Ապրանքը թանկանում է՝ վանելով օրինական հաճախորդների
\item Երկարում է գովազդելու ժամանակը, թույլ տալով ավելի քիչ պահպանողական
	մրցակցին ավելի արագ աշխատել
\end{enumerate}

Վերը թվարկած մեթոդները հաճախ օգտագործվում են համատեղ, և այդ դեպքում
դրանց բացասական ազդեցությունները գումարվում են։ Այդ պատճառով կարևոր է
հիշել նշված ազդեցությունները պաշտպանություն օգտագործելիս։

\subsection{Պաշտպանության գնահատում}
Մեզ անհրաժեշտ են ուղիներ վերը նշված պաշտպանության մեթոդների
արդյունավետրությունը գնահատելու համար։ Այդ նպատակով օգտագործվում են հետևյալ
ցուցանիշները՝
\begin{enumerate}
\item Կարողություն\\
	Ցույց է տալիս թե փորձառու հակառակորդի համար որքան բարդ է հասկանալ կոդը։
	Համարվում է որ ծրագիրը ինչքան բարդ է, այնքան լավ է այն պաշտպանված։
\item Ճկունություն\\
    Ցույց է տալիս, թե որքան լավ է ծրագիրը դիմանում ավտոմատացված հարձակումներին։
\item Պաշտպանության գինը\\
	Ցույց է տալիս թե որքանով է ավելանում կատարման ժամանակը և ֆայլի չափը երբ
	օգտագործվում է այդ պաշտպանության մեթոդը։
\item Թաքնվածություն\\
	Ցույց է տալիս թե որքանով է հնարավոր թաքցնել ինչ֊որ տվյալներ կամ կոդի մաս
	փորձառու հակառակորդից։
\end{enumerate}

\section{PE ֆայլի կառուցվածքը}
PE (Portable Executable) ֆայլը դա ֆայլի ֆորմատ է՝ կատարվող ֆայլերի, օբյեկտային
կոդի և DLL֊ների համար։ Այն ստեղծվել է Մայքրոսոֆթի կողմից 90-ական թթ սկզբներին։
Այն բաղկացած է գլխամասից, որին հետևում են տվյալների կառուցվածքները
(սեկցիաները)։ PE ֆայլերը չեն բեռնվում հիշողություն այն տեսքով, ինչպիսին նրանք
պահվում են սկավառակի վրա, փոխարենը նրանք բեռնվում են ըստ PE ֆայլի գլխամասում
գտնվող ինֆորմացիայի։ Ի տարբերություն MS-DOS֊ի, սեգմենտային ռեգիստրները չեն
օգտագործվում կոդը և տվյալները վերատեղավորելու համար, և դրա փոխարեն սեկցիաները
օգտագործվում են ծրագրային կոդ, փոփոխականներ, հաստատուններ և ռեսուրսներ պահելու
համար։ Որտեղ հնարավոր է, PE ֆայլի ֆորմատը պահում է այս սեկցիաները սեղմված
վիճակում, պահելով ինֆորմացիա այն մասին, թե ինչքան հիշողություն հարկավոր կլինի,
ի տարբերություն իրական տվյալների։ Նաև ի տարբերություն MS-DOS-ի, Վինդոուսը
վերագրում է 4ԳԲ հիշողության տարածություն յուրաքանչյուր բեռնված ծրագրի։

Վերծանման և ծրագրերի պաշտպանության ասպարեզում կարևոր է հասկանալ PE ֆայլերի
կառուցվածքը։ Դա նույնիսկ ավելի կարևոր է երբ գործ ունենք սեղմող/բացող ծրագրերի
հետ, և երբ կատարվող ֆայլերին ավելացնում ենք մեր կոդը (keygen֊ներ, այլ
ֆունկցիոնալություն և այլն)

\subsection{Գլխամաս}
Գլխամասը ունի 0x1000 բայտ երկարություն և կազմված է՝

\subsubsection{DOS֊ի գլխամաս և մաս}
DOS գլխամասը և մասը անտեսվում են Վինդոուս բեռնիչի կողմից, բացի՝

\begin{itemize}
\item EXE֊ի ստորագրության առաջին 2 բայտից։ Սրանք պետք է լինեն "MZ" այնպես որ
	ֆայլը ընդունվի որպես վավեր .exe։
\item DOS գլխամասի վերջին մասը, 0x3C հասցեում գտնվող երկակի բառը։ Սա
	PE գլխամասի վրա ցույց տվող հասցե է, հարաբերական ֆայլի սկզբին, DOS֊ի մասից
	անմիջապես հետո։ 
\end{itemize}

DOS֊ի մասում եղած կոդը կատարվում է միայն եթե ֆայլը կատարվում է DOS֊ի
միջավայրում կամ հրամանային տողից։ Վերոնշյալ դեպքում այն սովորաբար տպում է
հաղորդագրություն ինչպես "This program cannot be run in DOS mode." և ավարտում է
աշխատանքը։

DOS֊ի գլխամասը 0x40 բայտ երկարություն ունի, և DOS-ի մասի չափը կախված է
PE գլխամասի հասցեից։

\subsubsection{PE գլխամաս}
PE գլխամասը սկսվում է 4֊բայտանոց ստորագրությամբ ֊ այն պետք է լինի
"\texttt{PE\textbackslash0\textbackslash0}" որպեսզի ֆայլը գրանցվի որպես
վավեր .exe։

Ստորագրությանը հետևում է Ֆայլի Գլխամասը որը պարունակում է ինֆորմացիա
ֆայլի ֆիզիկական կառուցվածքի և հատկությունների մասին։ Այն 20 բայտ երկարություն
ունի և բաղկացած է՝

\begin{itemize}
\item Մեքենայի ճարտարապետություն
\item Սեկցիաների քանակ
\item Ամսաթվի և ժամվա կնիք
\item Սիմվոլների աղյուսակի վրա ցուցիչ (0 պատկերի համար)
\item Սիմվոլների քանակ (0 պատկերի համար)
\item Կամայական գլխամասի չափ
\item Հատկություններ
\end{itemize}

\subsubsection{Կամայական գլխամաս}
Հաջորդը կամայական գլխամասն է, որը պարունակում է PE ֆայլի ներքին տրամաբանական
կառուցվածքի մասին ինֆորմացիա։ Այս սեկցիան 224 բայտ երկարություն ունի, որոնցից
վերջին 128֊ը Տվյալների Դիրեկտորիան է։ Այս սեկցիան միշտ անհրաժեշտ է
յուրաքանչյուր .exe ֆայլի համար, չնայած անվանը։

Կամայակն գլխամասը պարունակում է այնպիսի ինֆորմացիա ինչպես՝

\begin{itemize}
\item Լինկերի, ՕՀ, պատկերի, ենթահամակարգի վերսիաներ
\item Պատկերի բազային հասցե
\item Կոդի և տվյալների բազային հասցե և չափ
\item Մուտքի կետի հասցե
\item Ստեկի, պատկերի և գլխամասի չափ
\item Սեկցիաների դասավորություն ֆայլի և հիշողության մեջ
\item Ֆայլի ստուգման թիվ
\item Դրոշակներ և բնութագրեր, և այլն
\end{itemize}

\subsubsection{Տվյալների դիրեկտորիաներ}
Տեխնիկապես հանդիսանալով կամայական գլխամասի մաս, այս կառուցվածքը
16 հատ IMAGE\_DATA\_DIRECTORY կառուցվածքների զանգված է։ ամեն կառուցվածքը
8 բայտ երկարություն ունի, և պարունակում է ինֆորմացիա նախանշված բանի մասին,
ինչպես օրինակ ներմուծման աղյուսակը։ Ամեն կառուցվածք բաղկացած է 2 երկակի
բառից, որոնք պարունակում են հարցակաի տակ գտնվող տվյալների կառուցվածքի
հարաբերական վիրտուալ հասցեն (RVA) և չափը։

Դիրեկտորիաները պարունակում են ինֆորմացիա ինչպես ներմուծման և արտածման
աղյուսակները, ռեսուրսները, բացառությունների բռնման համար ինֆորմացիա,
կարգաբերման, հեղինակային իրավունքի մասին բաժիններ և այլն։

\subsubsection{Սեկցիաների աղյուսակ}
Սեկցիաների աղյուսակը IMAGE\_SECTION\_HEADER կառուցվածքների զանգված է, որոնցից
յուրաքանչյուրը պարունակում է ինֆորմացիա PE ֆայլի մի բաժինի մասին,
ինչպես օրինակ՝
\begin{itemize}
\item բաժինի անունը, 8 բայտ երկարությամբ
\item Սկավառակի վրա բաժինի դիրքը և չափը
\item Վիրտւալ հասցեն, որում բաժինը պետք է բեռնվի
\item Հատկություններ
\item Վերատեղավորման և տողերի համարների ինֆորմացիա
\end{itemize}

բաժինների անունները անտեսվում են, բայց ծրագրավորողների հարմարության համար
դրանք սովորաբար կոչվում են՝

\begin{itemize}
\item .text - Կատարվող կոդ
\item .data - Կարդացվող և գրվող տվյալներ
\item .bss - Չսկզբնարժեքավորված տվյալներ
\item .rdata - Միայն կարդացվող տվյալներ
\item .edata, .idata - Ներմուծվող և արտահանվող տվյալների բաժիններ
\item .rsrc - Windowsի ռեսուրսներ (պատկերներ, նկարներ, տեքստային տողեր և այլն)
\item .src, .debug - Կարգաբերման համար ինֆորմացիա
\item .reloc - Բազային վերատեղավորումներ, պարունակում է ինֆորմացիա այն մասին
	թե որտեղ է լինկերը համարում որ սեկցիաները կբեռնվեն, որ հասցեները հնարավոր
	լինի հետագայում ուղղել։
\end{itemize}

\subsection{Բաժիններ}
Գլխամասին հաջորդում են բաժինները որոնք պարունակում են փաստացի կոդը,
տվյալները, ռեսուրսները և այլն։

Սկավառակի վրա ֆայլի մեջ, ամեն բաժին սկսվում է մի հասցեյում, որը կամայական
գլխամասի FileAlignment արժեեքի բազմապատիկն է։ Յուրաքանչյուր բաժին միջև լցված
են 0 արժեքով բայթեր։ Հիշողություն բեռնվելիս բաժինները միշտ սկսվում են
էջերի սահմանին, այնպես որ յուրաքնչյուր բաժինի առաջին բայթը համապատասխանում է
հիշողության էջի սկզբին։ X86 համակարգերում SectionAlginment արժեքը 4Կբ է։

Սկավառակի վրա PE ֆայլերի տվյալների այս կառուցվածքները նույն տվյալների
կառուցվածքներն են երբ նրանք բեռնվում են հիշողություն։ Կատարման ժամանակ
Win32 բեռնիչը պարզապես վերագրում է տվյալների այս կառուցվածքները հիշողությանը։

Յուրաքանչյուր պրոցես տեսնում է հիշողությունը որպես բայտերի 4Գբ֊անոց զանգված։
Գործնականում այս զանվածի միայն որոշ մասն է տեսանելի և հասանելի մեր ծրագրի
կողմից։

\subsection{Վինդոուս բեռնիչ}
Երբ PE ֆորմատի ֆայլը պատրաստվում է կատարման համար, ֆայլի կոթը փոխանցվում է
CreateProcess() API ֆունկցիային և ստատիկորեն ներմուծված DLL֊ները բեռնվում են
(EXE և DLL ֆայլերը երկուսն էլ PE ֆորմատի ֆայլեր են և նույական են, բացառությամբ
դրոշների մի բիթի)։ Սկզբնարժեքավորումը կատարվում է ՕՀ֊ի բեռնիչ կոչվող մասի
կողմից, որը մանրամասն նկարագրված է այս բաժնում։

Բեռնիչը կարդում է PE ֆայլի
գլխամասը և պատճենում է այն դեպի 32-բիթանոց ImageBase հասցե, որը վերցված է հենց
գլխամասից; եթե այս հասցեն արդեն օգտագործվում է, բեռնիչը ընտրում է մի այլ
հասցե։ Հետո այն կարդում է յուրաքանչյուր բաժին և պատճենում է դրանք
հիշողությունում։ Հնարավոր է երկու տարբեր դասավորումներ նշվեն՝ ֆայլի դասավորում
և բաժինների դասավորում։ Եթե այս դասավորումեները տարբեր են, բեռնիչը պատճենում
է յուրաքանչյուր բաժինը հիշողություն ըստ բաժինների դասավորման, ինչը
հանգեցնում է նրան, որ հիշողության կառուցվածքը տարբերվում է ֆայլի կառուցվածքից։
Եթե բեռնիչը օգտագործում է գլխամասում նշվածից տարբեր ImageBase հասցե, ինչպես
հաճախ տեղի է ունենում .dll ֆայլերում, ապա հասցեներրը անհրաժեշտ է
վերատեղավորել։ Հարաբերական թռիչքները և կանչերը հարկավոր չէ փոխել, բայց բոլոր
բացարձակ հասցեները (որոնք հաշվարկվում են ծրագրի թարգմանման ժամանակ լինկերի
կողմից) պետք է ճշտվեն՝ վերցնելով նախընտրելի ImageBase-ի և ընտրված ImageBase-ի
միջև տարբերությունը և հասցեները համապատասխանաբար փոխելով։ Համարյա բոլոր
ծրագրերին անհրաժեշտ են ինչ֊որ DLL֊ներ։ Windowsի հասարակ կատարվող ֆայլերը
չեն կարող կանչել int ընդհատումներ (ի տարբերություն MS-DOS֊ի) և պետք է
կանչեն API֊ը որպեսզի կարողանան կատարել օգտակար գործողություններ։
Բեռնիչը բեռնում է ստատիկորեն ներմուծված DLL֊ները, վերլուծում API կանչերը
և գրում API կանչերի հասցեները հիշողությունում։ Այս պրոցեսների ավարտից
հետո պրոցեսների հիշողության դասավորությունը կտարբերվի PE ֆայլի
դասավորությունից՝ դասավորման, սեկցիաների երկարության, հասցեների վերատեղավորման
և API վերլուծման իմաստով։ Եթե ծրագրի կատարումը սկսվել է, փոփոխական տվյալների
բաժինը կփչանա։

\section{Կնուտի խառնման ալգորիթմ}
Այս աշխատանքում նկարագրված մեթոդը օգտագործում է Կնուտի ալգորիթմը
բաժինների անունների հերթականությունը պատահականացնելու համար։

Խառնումը դա պրոցես է երբ բազմության տարրերի հերթականությունը պատահականացվում
է՝ տարրերի պատահական հերթականություն ստանալու նպատակով։ Սրա ամենատարածված
կիրառումներից է խաղաթղթերի կապոցի խառնումը։

Մաթեմատիկորեն խառնման խնդիրը իրականում N օբյեկտների պատահական
վերադասավորումը հաշվարկելու խնդիր է։

Կնուտի խառնման ալգորիթմը (ի պատիվ Դոնալդ Կնուտի), նաև հայտնի որպես
Ֆիշեր֊Յատեսի խառնում, ալգորիթմ է վերջավոր բազմության պատահական վերադասավորման
գեներացման համար։

Կան այս խնդրի մի քանի լավ ուսումնասիրված լուծումներ, որոնցից մեկն է
$O(n\lg n)$ ալգորիթմը։ Լուծումը շատ պարզ է՝ կապոցի յուրաքանչյուր քարին
վերագրվում է մի պատահական թիվ, և քարերը դասավորվում են ըստ իրենց վերագրված
թվերի։ Այս դեպքում կա հավանականություն, որ քարերից մի քանիսին նույն թիվը
կվերագրվի։ Սա կարելի է ստուգել ամեն անգամ երբ թիվ ենք վերագրում, կամ
ավելի լավ է՝ ստուգել երբ քարերը դասավորվում են և նորից փորձել։

Կա ավելի նրբագեղ և արագ ալգորիթմ, որը կոչվում է Կնուտի խառնում, որը հանրաճանաչ
է դարձել Կնուտի «The Art of Computer Programming» գրքում։ Իրականում ալգորիթմը
սկզբնապես հրատարակվել է Ռ․ Ա․ Ֆիշերի և Ֆ․ Յատեսի կողմից 1938 թ․ Լոնդոնում
համակարգչային լեզվով։ Ահա ալգորիթմի նկարագրությունը հասարակ լեզվով՝

Ենթադրենք $X_{1}, X_{2}, ..., X_{N}$֊ը $N$ հատ թվերի բազմություն է որը պետք է
խառնել։

\begin{enumerate}
\item $i$֊ին վերագրել $N$
\item $j$֊ին վերագրել պատահական թիվ $1$֊ի և $i$֊ի միջև
\item Փոխանակել $X_i$ և $X_j$֊ն
\item $i$֊ն $1$֊ով նվազեցնել
\item Վերադառնալ 2֊րդ քայլին եթե $i$֊ն $0$ չի
\end{enumerate}

Ֆիշեր֊Յատեսի խառնումը կատարվում է տեղում։ Այսինքն, եթե տրված է
սկզբնարժեքավորված զանգված, այս ալգորիթմը խառնում է տարրերը տեղում, և ոչ թե
գեներացնում այդ զանգվածի խառնված պատճեն։ Սա կարող է լինել առավելություն եթե
խառնվող զանգվածը մեծ է։

Հետևյալը ալգորիթմի իրականացումն է մեր նախագծի համար, \texttt{shuffle.c} ֆայլից։

\begin{lstlisting}
#include <string.h> // memcpy()
#include <stdlib.h> // malloc(), free(), rand()
#include <stdio.h>

#include "winnt.h"

static int Swap(unsigned char *a, unsigned char *b)
{
    void *temp = malloc(IMAGE_SIZEOF_SHORT_NAME);
    if (temp == NULL) {
        perror("Could not allocate memory");
        return 1;
    }

    memcpy(temp, a, IMAGE_SIZEOF_SHORT_NAME);
    memcpy(a, b, IMAGE_SIZEOF_SHORT_NAME);
    memcpy(b, temp, IMAGE_SIZEOF_SHORT_NAME);
    free(temp);

    return 0;
}

int Shuffle(unsigned char * arr[], int length)
{
    int random;

    int i;
    for (i = 0; i != length; i++) {
        random = rand() % (length - i);

        if (Swap(arr[ length - 1 - i ], arr[ random ])) {
            return 1;
        }
    }

    return 0;
}
\end{lstlisting}

\section{Պաշտպանություն սեկցիաների անունների խառնման միջոցով}
Այս թեզը ներկայացնում է օբֆուսկացիայի մի մեթոդ, որի ժամանակ չարամիտ
օգտագործողի կողմից (հակառակորդի) ծրագրի վերլուծությունը դժվարացնում է
PE գլխամասում գտնվող բաժինների անունների խառնման միջոցով։

Գաղափարն այն է որ հակառակորդի համար դժվարանում է գտնել այն բաժինը, որում
նա ցանկանում է փոփոխություններ կատարել։ Սա կատարվում է բաժինների անունները
խառնելու միջոցով փոփոխելով։ Խառնումը կատարվում է օգտագործելով Կնուտի խառնման
ալգորիթմը (տե՛ս հաջորդ գլուխը)։

Նախ ծրագիրը անցնում է PE գլխամասի վրայով, հետո կարդում է բաժինների անունները
մի զանգվածի մեջ։ Այնուհետև զանգվածը խառնելուց հետո բաժինների անունները հետ
են գրվում ֆայլի մեջ։

Ծրագիրը նաև բաժինների հին և նոր հերթականությունները տպում է stdout֊ում։

Նույնիսկ եթե հակառակորդը ամբողջովին հասկանա այս մեթոդը, նույնիսկ այդ դեպքում
նրանից կպահանջվի որոշ ժամանակ՝ յուրաքանչյուր բաժինի դերը հասկանալու համար,
քանի որ բաժինների անունները ամեն անգամ ընտրվում են պատահականորեն։

Որպեսզի հակառակորդը կարողանա կատարել հաջող վերլուծություն, նա պետք է
նայի յուրաքանչյուր բաժինի հատկություններին և հետազոտի նրանց պարունակությունը
որպեսզի հասկանա նրանց նշանակությունը, իսկ դա հակառակորդից պահանջում է
լրացուցիչ ժամանակ։

Ներկայացված մեթոդը հնարավոր է հեշտորեն ավտոմատացնել և չի պահանջում ոչ մի
լրացուցիչ մուտք կամ կարգավորում ծրագրերի հեղինակների կողմից։ Այս մեթոդը չունի
4.4 բաժնում նշված բացասական ազդեցություններից որևէ մեկը։

Իրականացումը գրված է C լեզվով և օգտագործում է տվյալների կառուցվածքներ
\texttt{winnt.h} համակարգային header-ից։ Ծրագիրը աշխատում է և՛ Windows և՛
Լինուքս համակարգերի տակ։

Կարևոր է հիշել որ այս մեթոդը, ինչպես համարյա ցանկացած այլ
պաշտպանության մեթոդ չի պաշտպանում կատարվող ֆայլը հնարավոր մոդիֆիկացիաներից։
Այն միայն դժվարացնում է հետազոտության և փոփոխությունների կատարման փուլերը՝
հակառակորդից ժամանակ խլելու միջոցով։

Իրականացման ամբողջական կոդը կարելի է ներբեռնել հետևյալ հասցեյից՝
\url{https://github.com/axper/shuffle-pe-section-names-clean}
(նաև տես Հավելված 1)

Իրականացման հիմնական ֆունկցիան հետևյալն է՝

\begin{lstlisting}
int ParseFile(FILE *file)
{
    IMAGE_DOS_HEADER dosHeader;
    IMAGE_NT_HEADERS header;

    if (ReadDosHeader(file, &dosHeader)) {
        return 1;
    }

    if (ReadPeHeader(file, &header, dosHeader.e_lfanew)) {
        return 1;
    }

    int sectionCount = header.FileHeader.NumberOfSections;
    IMAGE_SECTION_HEADER sections[ sectionCount ];

    if (ReadSections(file, sections, sectionCount)) {
        return 1;
    }

    unsigned char *names[ sectionCount ];
    ReadSectionNames(sections, names, sectionCount);

    printf("Old order: ");
    PrintSectionNames(names, sectionCount);

    if (Shuffle(names, sectionCount)) {
        return 1;
    }

    printf("New order: ");
    PrintSectionNames(names, sectionCount);

    if (WriteSectionNames(file,
                          dosHeader.e_lfanew +
                          sizeof(IMAGE_NT_HEADERS),
                          names,
                          sectionCount)) {
        return 1;
    }

    return 0;
}
\end{lstlisting}

\newpage
\section{Եզրակացություն}
Քանի որ պաշտպանության այս մեթոդը կիրառվում է արդեն թարգմանված կատարվող ֆայլերի
վրա, դա նշանակում է ծրագրային կոդի մեջ ոչ մի փոփոխություն անհրաժեշտ չէ։
Սա իր հերթին նշանակում է որ 4.4 բաժնում թվարկված ծրագրային պաշտպանության
վատ ազդեցությունները մեր մեթոդում առկա չեն։

Պաշտպանության այս մեթոդը կարող է օգտագործվել ցանկացած այլ պաշտպանության մեթոդի
հետ համատեղ, քանի որ այն ոչինչ չի փոխում բացի PE գլխամասում բաժինների
անուններից։

Քանի որ բաժինների անունները գեներացվում են պատահականորեն, այս մեթոդը
դիմագրավում է այսպես կոչված «կոտրեք մի անգամ ֊ օգտագործեք ամենուրեք» տիպի
գրոհներին։

Պաշտպանության ներկայացված մեթոդը արդյունավետ է հատկապես դինամիկ գրոհների
դեմ պայքարելիս։

Իրականացման աշխատանքի պատկերը տես հավելված 2֊ում։

\newpage
\section*{Գրականության ցանկ}
\addcontentsline{toc}{section}{\protect\numberline{}Գրականության ցանկ}
\begin{enumerate}
\item A Museum of API Obfuscation on Win32\\
	\url{http://www.symantec.com/content/en/us/enterprise/media/security_response/whitepapers/a_museum_of_api_obfuscation_on_win32.pdf}
\item A Software Protection Method Based on Instruction Camouflage\\
	\url{http://tekpool.wordpress.com/2006/10/06/}
\item A Software Protection Method Based on Instruction Camouflage\\
	\url{ws.cs.kobe-u.ac.jp/achieve/data/pdf/93.pdf}
\item Code Obfuscation Techniques for Software Protection\\
	\url{https://www.cosic.esat.kuleuven.be/publications/thesis-199.pdf}
\item Lenas Reversing for Newbies\\
	\url{https://tuts4you.com/download.php?list.17}
\item Portable Executable File Format Compendium v11 by Goppit\\
	\url{http://arteam.accessroot.com/arteam/site/download.php?view.112}
\item R4ndom’s Beginning Reverse Engineering Tutorials\\
	\url{http://thelegendofrandom.com/blog/sample-page}
\item Software Protection Against Reverse Engineering Tools\\
	\url{http://www.dtic.mil/get-tr-doc/pdf?AD=ADA469485}
\item Software Protection through Code Obfuscation Aniket Kulkarni\\
	\url{http://www.coep.org.in/page_assets/341/121003016.pdf}
\item Software reverse engineering education\\
	\url{http://scholarworks.sjsu.edu/cgi/viewcontent.cgi?article=4730&context=etd_theses}
\item Wikibooks - x86 Disassembly/Windows Executable Files\\
	\url{https://en.wikibooks.org/wiki/X86_Disassembly/Windows_Executable_Files}
\item Windows and its PE file structure\\
	\url{http://aerokid240.blogspot.com/2011/03/}
\item \url{http://www.stackexchange.com/}
\end{enumerate}

\newpage
\lhead{ՀԱՎԵԼՎԱԾ}
\vspace*{\fill}
\begingroup
\centering
\centerline{\Huge{ՀԱՎԵԼՎԱԾ}}
\endgroup
\vspace*{\fill}
\newpage

\lhead{ՀԱՎԵԼՎԱԾ 1}
\section*{Հավելված}
\addcontentsline{toc}{section}{\protect\numberline{}Հավելված}
\subsection*{Սկզբնական կոդ}
\addcontentsline{toc}{subsection}{\protect\numberline{}Սկզբնական կոդ}

\textit{main.c}
\lstinputlisting{shuffle-pe-section-names-clean/main.c}
\textit{shuffle.c}
\lstinputlisting{shuffle-pe-section-names-clean/shuffle.c}
\textit{shuffle.h}
\lstinputlisting{shuffle-pe-section-names-clean/shuffle.h}
\textit{winnt.h}
\lstinputlisting{shuffle-pe-section-names-clean/winnt.h}
\textit{CMakeLists.txt}
\lstinputlisting{shuffle-pe-section-names-clean/CMakeLists.txt}

\newpage
\subsection*{Իրականացման աշխատանքը}
\lhead{ՀԱՎԵԼՎԱԾ 2}
\addcontentsline{toc}{subsection}{\protect\numberline{}Իրականացման աշխատանքը}

\begin{figure}[h!]
  \caption{Իրականացման աշխատանքը}
  \centering
    \includegraphics[width=0.8\textwidth]{terminal.png}
\end{figure}
\begin{figure}[h!]
  \caption{Ծրագրի սեկցիաները OllyDBG֊ում օբֆուսկացիայից առաջ և հետո}
  \centering
    \includegraphics[width=0.48\textwidth]{before.png}
    \includegraphics[width=0.48\textwidth]{after.png}
\end{figure}
\newpage
\lhead{}
\setcounter{page}{45}

\section*{Մթնոլորտի աղտոտման խնդիրները}
Ժամանակակից քաղաքակրթությունը չտեսնված ճնշում է գործադրում բնության վրա: Արդյունաբերական թափոններով բնական միջավայրի աղտոտումը վնասակա ազդեցություն է գործում մարդկանց, կենդանիների, բույսերի, հողի, շենքերի և շինությունների վրա, իջեցնում է մթնոլորտի թափանցիկությունը, բարձրացնում է օդի խոնավությունը, մեծացնում է մառախլապատ օրերի թիվը, փոքրացնում է տեսանելիությունը, առաջ է բերում մետաաղկան իրերի կոռոզիա:

Շրջական միջավայրի աղտոտման տակ հարկ է հասկանալ միջավայրի հատկությունների (քիմիական, մեխանիկական, ֆիզիկական, կենսաբանական և դրանց հետ կապված տեղեկատվական) փոփոխությունը, որոնք տեղի են ունենում բնական կամ արհեստական գործընթացների արդյունքում և հանգեցնում են միջավայրի ֆունկցիայի վատթարացմանը` ցանկացած կենսաբանական կամ տեխնոլոգիական օբյեկտի առումով: Իր գործունեության մեջ օգտագործելով շրջակա միջավայրի զանազան տարրեր` մարդը փոխում է դրանց որակը: Հաճախ այդ փոփոխությունները արտահայտվում են աղտոտման ոչ բարենպաստ ձևերով: Իրենց մասշտաբներով մարդածին փոփոխությունները համադրելի են դառնում բնականների հետ, իսկ մի շարք դեպքերում անգամ գերազանցում են դրանք:

Աղտոտման բնական գործընթացները բնության մեջ անտիպոդներ ունեն, որոնք ընդունակ են չեզոքացնել բնական աղտոտման ազդեցությունը, իսկ մարդու ստեղծած շատ նյութեր տարաասեռ են բնականների համեմատությամբ: աղտոտման բնական աղբյուրները սովորաբար հեռացված են մարդու բնակության վայրերից, այնինչ մարդածինները տեղադրված են խիտ բնակչությամբ շրջաններում:

Լուծման հիմնական ուղիները մթնոլորտի աղտոտման մասշտաբների մեծացումը պահանջում է այն աղտոտումներից պաշտպանելու արագ և արդյունավետ միջոցներ, ինչպես նաև` օդի աղտոտումների վնասակար ազդեցության կանխումը: Մթնոլորտը կարող է առանց վնասակար ազդեցության արտահայտման պարունակել աղտոտումների որոշակի քանակ, քանի որ տեղի է ունենում նրա մաքրման բնական գործընթաց:

Օդի աղտոտման հետ կապված վնասակար ազդեցության որոշման առաջին քայլը հանդիսանում է օդի որակների չափանիշների մշակումը, ինչպես նաև` որակի ստանդարտները:

Որակի ստանդարտները որոշում են օդի որակի մակարդակները և սահմանային թույլատրելի արտանետումները (ՍԹԱ), որոնք անհրաժեշտ է պահպանել` անվտանգ կայնքի ապահովման համար:

Վերահսկող մարմինները պարտավոր են որակական և քանակական վերահսկողություն իրականացնել:

Մթնոլորտի վիճակի բարելավման այլ մոտեցում է հանդիսանում առաջավոր տեխնոլոգիական գործընթացների կիրառումը, վնասակար նյութերի փոխարինումը անվնասներով, հումքի մշակման չոր եղանակների փոխարեն խոնավների կիրառումը:

Որպես կանոն, արդյունաբերական ձեռնարկություններում օգտագործվում են գազամաքրման և փոշեորսման գործընթացներ կամ սարքեր` փոքրացնելու կամ կանխելու համար արտանետման մեծությունը: Գազամաքրման գործընթացները կարող են նաև քայքայել կամ փոխել նրանց քիմիական կամ ֆիզիկական հատկություններն այնպես, որ այն դառնա պակաս վտանգավոր:

Որոշ դեպքերում օգտագործում են մթնոլորտում նոսրացման մեթոդը: Ծխնելույզները պետք է բավականաչափ բարձր լինեն (300-350 մետր)` աէրոդինակիմ ստվերների գոտում շենքի շուրջը օդի հոսանքի ճանապարհով խառնուրդների լավ նոսրացումն ապահովելու համար: Բացի դրանից, անհրաժեշտ է հաշվի առնել արտանետումների ջերմաստիճանը և խողովակների տեղը: Ձեռնարկությունները կառուցում են քամոտ վայրերում: Մի շարք ձեռնարկություններում գազերն օգտագործվում են շենքերի ջեռուցման համար, իսկ դրանց ավելցուկն ուղղվում է ջերմակենտրոն:

Ըստ մասշտաբների` շրջակա միջավայրի աղտոտումը կարելի է բաժանել տեղայինի, տարածաշրջանայինի և համաշխարհայինի: Աղտոտման այս երեք տեսակները սերտորեն կապված են մեկը մյուսի հետ: Որպես կանոն, առաջնային է հանդիսանում տեղային աղտոտումը, որը, եթե գործընթացի արագությունը ավելի մեծ է բնական մաքրման արագությունից, վերածվում է տարածաշրջանայինի և հետո, քանակական փոփոխությունների կուտակման դեպքում, շրջակա միջավայրիօ գլոբալ փոփոխության: Գլոբալ աղտոտման համար առավել կարևոր է հանդիսանում ժամանակային գործոնը:

Այդպիսի գործընթացների գոյությունը վկայում է մթնոլորտի ռեսուրսների ասահմանափակության և նրա բնական ինքնավերականգնման սահմանների մասին: Օրինակ, արդյունաբերական գործընթացներում օդի օգտագործումը հնուց ենթադրում էր սկզբնական որակները վերականգնելու` մթնոլորտի բնական ընդունակությունը: Մասնավորապես, մթնոլորտ ծխային արտանետումները, որոնք միկրոմասնիկներ և թունավոր նյութեր են պարունակում, իրենից ներկայացնում է ոչ այլ ինչ, քան նոսրացման մեթոդ: Եվ անգամ մեր օրերում բարձր և գերբարձր խողովակների կառուցումը շարունակում է օգտագործել այդ հնագույն մեթոդը: Սակայն արտանետումների ծավալների կտրուկ աճը հանգեցրեց այն բանին, որ աղտոտման մասշտաբները լիովին մոտեցել են և անգամ հաճախ անցնում են մթնոլորտի ինքնավերականգնման սահմանները:

Աղտոտման ժամանակակից մեթոդների դեպքում վնասակար նյութերը աղբյուրից տարածվում են տասնյակ և հաևյուրավեր կիլոմետրերիով: Եվ անգամ բունաղտոտման աղբյուր հասկացությունը որոշ չափով փոխել է իր իմաստը: Եթե որևէ արդյունաբերական շրջանում կարելի է առանձնացնել աղտոտման կետային աղբյուրներ, ապա տարածաշրջանի մասշտաբով ամբողջ արդյունաբերական շրջանը, օրինակ` քաղաքը, կարող է դիտարկվել որպես միասնական աղբյուր` կետային, գծային (ավտոմայրուղիներ) և խմբային աղբյուրներով: Ավելին, անգամ ամբողջ շրջանը, և անգամ ամբողջ երկիրը կորղ է հանդես գալ աղտոտման միասնական աղբյուրի դերում:

   Ժամանակակից արդյունաբերական արտադրությունը նշանակալի ազդեցություն է գործում բնության վրա գլոբալ մասշտաբներով: Թեև աղտոտող նոյւթերի և ջերմային էներգայի մեծ մասը արտադրվում է սահմանափակ տարածության վրա, գլխավորապես` Հյուսիսային Ամերիկայի, Եվրոպայի և Ասիայի արդյունաբերական շրջաններում, մթնոլորտի շրջանառության առանձնահատկությունների և Երկրի ջրային թաղանթի տեղափոխումների հետևանքով որոշ, համեմատաբար երկարակյաց թունավոր նյութեր տարածվում է հսկայական տարածություններում, և անգամ ամբողջ Երկրի վրա` հանգեցնելով տարածաշրջանային և գլոբալ աղտոտման:

Ներկայումս որոշակիացել են շրջական բնական միջավայրի մարդածին գլոբալ աղտոտման որոշ կարևոր խնդիրներ, որոնցից են.

\begin{enumerate}
\item Կլիմայի հնարավոր փոփոխությունները` կապված մթնոլորտ տեխնոլոգիական ջերմության, ածխաթթու գազի և աէրոզոլերի թափանցման հետ
\item Երկրի հիմնական շերտի հնարավոր քայքայումը` կապված մթնոլորտ ֆրեոնների, ազոտի օքսիդների և որոշ այլ խառնուրդների թափանցման հետ,
\item Բնական միջավայրի և կենսոլորտի` ռադիոակտիվ նյութերով, ծանր մետաղներով և պեստիցիդներով գլոբալ աղտոտման էկոլոգիական հետևանքները,
\item Ծովային միջավայրի` մթնոլորտային տեղումներով, գետերի հոսանքներով, ցամաքային և ծովային տրանսպորտով ընդհանուր աղտոտումը,
\item Աղտոտող նյութերի հեռավոր մթնոլորտային փոխադրումը և թթվային տեղումների խնդիրը:
\end{enumerate}

Այսպիսով, շրջակա միջավայրի վրա մարդածին ազդեցության մասշտաբները և դրանից բխող վտանգները ստիպում են նոր մոտեցումներ փնտրել տեխնոլոգիական գործընթացների զարգացմանը, որոնք, հանդիսանալով ոչ պակաս արդյունավետ` տնտեսական իմաստով, շատ անգամ կգերազանցեին գոյություն ունեցողներին` էկոլոգիական մաքրության աստիճանով: Տնտեսության և էկոլոգիայի միջև գոյություն ունեցող փաստացի հակասությունը նշանակում է հակասություն` բնություն-մարդ-արտադրություն համակարգի ներդաշնակ զարգացման և անբավարար օբյեկտիվ հնարավորության միջև, իսկ երբեմն` պարզապես ցանկության սուբյեկտիվ բացակայութմաբ` արտադրողական ուժերի և արտադրական հարաբերությունների զարգացման ժամանակակից փուլում:

Մթնոլորտն աղտոտող նյութերը բազմաթիվ տասնամյակների ընթացքում նշանակալի վնաս էին հասցնում շրջակա միջավայրին: Ըստ էրևույթին, նրանց վնասակար ազդեցության հետ հարկ կլինի հաշվի նստել նաև ապագայում: Բնակչության և արդյունաբերական արտադրության հետագա աճը անխուսափելիորեն կհանգեցնեն աղտոտման վտանգի մեծացմանը:

Այն հիմնական աղտոտող նյութերի, որոնց պարունակությունը կանոնակարգվում է ստանդարտներով, հանդիսանում են ազոտի երկօքոսիդը (SO2), ազոտի օքսիդները (NO և NO2), ածխածնի օքսիդ (CO), գազային ածխաջրածիններ (HC), ինչպես նաև` ծծմբաջրածինը (H2S), ծծմբածխածինը (CS2), ամոնիակը (NH3), զանազան հալոգենպարունակող գազեր:

Գոյություն ունի գազային աղտոտիչների ձևավորման երեք հիմնական աղբյուրներ. վառելանյութերի այրում, արդյունաբերական արտադրական գործընթացներ և բնական աղբյուրներ: Վառելանյութի այրման արդյունքումէ առաջանում ծծմբի երկօքսիդի ամբողջ զանգվածի 78 տոկոսը: Ածխաջրածինները, որոնց առաջ գալու վտանգը կայանում է նրանում, որ դրանք միջանկյալ նյութեր են հանդիսանում օզոնի ձևավորման գործընթացում, մթնոլորտ մուտք են գործում վառելիքի այրման և նավթամթերքների վերամշակման դեպքում, բացի դրանից, շատ ածխաջրածիններ անջատվում են բույսերի աճի և բազմացման գործընթացում: Ըստ գիտնականների գնահատականների` բնական աղբյուրներից ամեն տարի անջատվում է 117 մլն. տոննա ածխաջրածին, իսկ նմարդածին աղբյուրներրից` 100 մլն. տոննա: Սակայն քաղաքների մթնոլորտում առկա ածխաջրածինները հիմնականում իրենցից ներկայացնում են այրման արդյունքներ:

Ծծմբի օքսիդների նշանակալի քանակություն մթնոլորտ է նետվում սուլֆիդային հանքերից պղնձի, կապարի և ցինկի արտադրության ժամանակ, ինչպես նաև` նավթամթերքների մաքրման գործընթացում: SO2-ի արտանետումների մեծ մասը կապված է գործընթացին անհրաժեշտ ջերմության ստացման համար վառելիքի այրման հետ: Առաջացած SO2 պարունակող գազերը սովորաբար օգտագործվում են ծծմբական թթվի արտադրության համար:

Ծծմբի օքսիդները նույնպես առաջ են գալիս թղթի և ցելյուլոզային զանգվածի արտադրության ժամանակ` ծծումբ պարունակող նյութերի այրման հետևանքով:

Ածխաջրածիններով մթնոլորտի աղտոտումը տեղի է ունենում քիմիական ձեռնարկություններից, նավթարդյունահանող և մետալուրգիական գործարաններից: Ածխաջրածինները, որոնք անջատվում են պլաստմասսաների, ներկանյութերի, սննդային հավելանյութերի, պեստիցիդների արտադրության, ինչպես նաև` կաուչուկների և նավթաքիմիական նյութերի վերամշակման ժամանակ:

Մթնոլորտ նետվող քիմիական նյութերի թվում պարունակվում է թունավոր նյութերի բավականաչափ նմեծ քանակություն: Ներկայումս վտանգավոր աղտոտող նյութերի թվին ենդասվում սնդիկի գոլորշիները, վինիլքլորիդը և բենզոլը, որոնց պարունակությունը մթնոլորտում ենթակա է հատուկ վերահսկողության:

Հանածո վառելիքի մեծ քանակություն է ամեն տարի այրվում կաթսայատներում` ջեռուցման համար: Կաթսայատները ամենից «կեղտոտ» վառելիքի` քարածխի և մազութի, ամենախոշոր սպառողներն են: Այդ պատճառով էներգետիկան ըստ այրվող վառելիքի քանակի և որակի հանդիսանում է ծծմբի երկօքսիդի միակ աղբյուրը, ինչպես նաև` դիսպերս աղտոտումների և ազոտի օքսիդի գլխավոր աղբյուրը:

Գազային աղտոտիչները առաջ են գազի այրման գործընթացում, իսկ դիսպերսները` մեխանիկական փոշին, կարող է դուրս փչվել կոնվեյերով ածխի բեռնաթափման և փոխադրման ժամանակ, ինչպես նաև` վառելիքային մոխրի հեռացման և պահեստավորման ժամանակ: Ածխի փոշիացումը տեղի է ունենում քամային էրոզիայի արդյունքում: Բնական ածխի փոշիացումը` որպես վառելիք, հանդիսանում է առավել արդյունավետ: Թեև բնական գազը դիտարկվում է որպես համեմատաբար մաքուր վառելիք, նրա այրման ժամանակ նույնպես ձևավորվում են աղտոտիչները` ազոտի օքսիդները, ածխածնի օքսիդները, ածխաջրածինները, ծուխը:

Մթնոլորտի աղտոտման ևս մեկ ոչ պակաս կարևոր աղբյուր է հանդիսանում պինդ քաղաքային թափոնների այրումը: Բոլոր քաղաքակիրթ երկրներում այդ նպատակի համար գոյություն ունեն աղբայրման վառարաններ, որոնց կառուցվածքից են կախված թափոնների բաղադրությունները:

Ծխային արտանետումները բաղկացած են այրման հարաբերաբար անվնաս գազային պրոդուկտներից` ածխածնի երկօքսիդ, ջուր, իներտ ազոտ: Սակայն դրանց ավելցուկը կարող է հանգեցնել շլեյֆային մառախուղի ձևավորմանը: Ծխային արտանետումների որսման համար օգտագործում են զանազան ֆիլտրեր և որսիչներ:

Ներքին այրման շարժիչների արտանետումներով շրջակա միջավայրի աղտոտումը վերջին տարիների ավելի ու ավելի սևեռուն ուշադրության են արժանանում` մարդու առողջությանն սպառնացող աճող վտանգի պատճառով:

Մթնոլորտում ածխաթթու գազի պարունակության մեծացումը տանում է Երկրի ջերմաստիճանի բարձրացման: CO2-ի պարունակության մեծացման դեպքում կարելի է սպասել Երկրի միջին ջերմաստիճանի բարձրացում, թեև այդ պարամետրերի միջև կախումը բավականաչափ բարդ է: Դատելով հետազոտությունների արդյունքներից` CO2-ի մոտավոր կրկնապատկում տեղի կուենա մոտ 20410 թվականին, ինչի արդյուքնում մոլորակի ջերմաստիճանը կբարձրանա 2-3 աստիճանով: Բևեռային շրջաններում ջերմաստիճանի բարձրացումը կարող է մի քանի անգամ գերազանցել տվյալ արժեքը:

Ջերմաստիճանի փոփոխության վրա մարդածին ազդեցության հիմնախնդիրը դեռևս մնում է քննարկման փուլում: Իհարկե, չի կարելի այդ ազդեցությունը հանգեցնել միայն «թերմոստատում ջերմաստիճանի բարձրացման», քանի որ ջերմաստիճանի գլոբալ բաշխումը կապված է մթնոլորտային զանգվածների տեղափոխման հետ:

Ջերմաստիճանի փոփոխության ժամանակ ջրային գոլորշու պարունակությունը նույնպես կարող է փոխվել: Այսպիսով, մթնոլորտում CO2-ի խտության փոփոխման վերջնական արդյունք կարող են դառնալ բարդ կլիմայական գործընթացները, որոնք կապված են ինչպես ջերմաստիճանի, այնպես էլ` տեղումների ձևավորման գործընթացում:

Առաջներում ենթադրվում էր, որ տրանսպորտային ավիացիայի արտանետած ազոտի օքսիդները հանդիսանում են օզոնի շերտի քայքայման հիմնական պատճառը: Սակայն քանակական չափումները ցույց տվեցին, որ այդ աղբյուրը չնչին է` բնականների համեմատությամբ: Մարդկային գործունեության արգասիքներից օզոնային շերտի համար առավել վտանգավոր են հանդիսանում ֆրեոնները և դրան նման նյութերը: Նրանք արհեստական ծագում ունեն և լայնորեն կիրառվում են սառնարանային հարմարանքներում, տարբեր աէրոզոլերում:

Օզոնը կազմում է մթնոլորտի աննշան մասը` մեկ միլիոներորդական մասին պակաս` և' ծավալով, և' զանգվածով: Նրա հիմնական մասը` մինչև 90 տոկոս, կենտրոնացված է ստրտոսֆերայում: Մնացած 10 տոկոսը կենտրոնացված են մթնոլորտի ավելի ցածր շերտերում: Այստեղ օզոնը արդեն հանդես է գալիս որպես մթնոլորտի օդի վտանգավոր աղտոտիչ: Այն ազդում է շնչառական ուղիների վրա, գրգռում է աչքերը, խախտում է բուսականության աճը և այլն: Շնչառության համար օգտագործվող օդում նրա կոնցենտրացիան պետք է կազմի չպետք է գերազանցի 150-200 մկգ/3-ը:

Օզոնը առաջ է գալիս էլեկտրական լիցքերի արդյունքում, սակայն շատ ավելի կարևոր են հանդիսանում միջնորդ նյութերի մասնակցությամբ ֆոտոքիմիական ռեակցիաները (ազոտի օքսիդները կամ ածխաջրածինները):    Լուծման արդյունքները Կապված ստեղծված սոցիալ-էկոլոգիական իրավիճակի առանձնահատկությունների հետ` ժամանակակից արդյունաբերությանը երկու պայման է ներկայացվում: Նախ, արտադրությունը պետք է ոչ միայն նյութական բարիքներ ստեղծի, այլ նաև վնասազերծի ի ր գործունեության արգասիքները: Երկրորդ` արտադրությանն արգասիքները օգտագործումից հետո համեմատաբար հեշտությամբ պետք է կրկին վերածվեն արտադրության արգասիքների:

Աղտոտումից մթնոլորտի արմատական մեթոդ է հանդիսանում մինչև մթնոլորտ մուտք գործելը դրանց լիկվիդացումը: Դրա համար անհրաժեշտ է անթափոն արտադրության կիրառությունը, բուն արտադրության մեջ տեխնոլոգիական գործընթացների հերմետիկացումը, վնասակար մնացորդների թափոնացումը:



\newpage
\setcounter{page}{52}
\section*{Աշխատանքային տեղամասի արհեստական լուսավորության կազմակերպումն ու հաշվարկը}

Աշխատանքային տեղում ճիշտ կազմակերպված լուսավորությունը ստեղծում է աշխատանքային բարենպաստ պայմաններ, բարձրացնում է աշխատունակությունն ու արտադրողականությունը:

Տեսողական օրգանների հոգնածությունը կախված է մի շարք պատճառներից`
\begin{itemize}
\item Անբավարար լուսավորություն,
\item Սահմանվածից ավել (կուրացուցիչ) լուսավորություն
\item Լույսի սխալ ուղղություն
\end{itemize}

Անբավարար լուսավորությունը բերում է տեսողության լարվածության, աշխատունակության անկման, նյարդային համակարգի խախտումների, որը և բերում է վաղաժամ հոգնածության:  Շատ պայծառ լուսավորությունը առաջացնում է կուրացում, աչքերի գրգռվածություն և ծակծկում:

Աշխատատեղի լուսավորումը լույսի սխալ ուղղությամբ բերում է ստվերների և ցոլքերի գոյացմանը, որոնք ապակողմնորոշում են աշխատողին և առաջացնում տեսողական օրգանների լարվածություն:

Բոլոր այդ պատճառները կարող են բերել դժբախտ պատահարների կամ պրոֆեսիոնալ հիվանդությունների: Այդ ամենը խիստ կարևոր են դարձնում լուսավորության ճիշտ հաշվարկումը:

Տեսողության համար օպտիմալ պայմաններ ստեղծելու համար անհրաժեշտ է հետևյալ պահանջները բավարարող լուսավորվածության համակարգ:
\begin{itemize}
\item Արհեստական լուսավորվածությունը աշխատանքային տեղերում պետք է համապատասխանի տեսողական աշխատանքի բնույթին :
\item Պայծառությունը աշխատանքային մակերևույթների վրա պետք է լինի հավասարաչափ բաշխված :
\item Աշխատանքային մակերևույթների վրա չպետք է լինեն ցայտուն ստվերներ :
\item Լուսավորվածությունը ամբողջ աշխատաժամանակի ընթացքում պետք է լինի հաստատուն:
\item Լույսի հոսքի ուղղվածությունը պետք է լինի օպտիմալ:
\item Լուսավորվածության տեղակայման բոլոր էլեմենտները պետք է բավարար երկարակյաց, էլեկտրաանվտանգ լինեն և չլինեն հրդեհի ու պայթյունի առաջացման աղբյուրներ: 
\end{itemize}

Լուսամփոփների տեսակի ընտրությունը կախված է տվյալ շինությունում կատարվող աշխատանքի բնույթից, օդային միջավայրի փոշոտման հնարավորությունից, շրջապատող մակերևույթների անդրադարձման գործակիցներից և գեղագիտական պահանջներից: Աշխատանքային շինություններում, որպես արհեստական լույսի աղբյուրներ, օգտագործվում են շիկաթել և լյումինեսցենտ (գազապարպումային) լամպերը: Նշված 2 լույսի աղբյուրներից կընտրենք լյումինեսցենտ լամպերը, քանի որ շիկաթել լամպերի համեմատությամբ լյումինեսցենտ լամպերն ունեն հետևյալ առավելությունները. 

\begin{itemize}
\item ունեն ցերեկային (բնական) լույսին զգալի մոտ լուսային սպեկտր,
\item օժտված են ավելի բարձր ՕԳԳ-ով (1,5-2 անգամ ավել է, քան շիկաթել լամպերի ՕԳԳ-ն),
\item ունեն բարձր լուսատվություն(3-4 անգամ ավել, քան շիկաթել լամպերը) և ավելի երկար ծառայության ժամկետ:
\end{itemize}

	Լուսային հոսքի գործակցի օգտագործմամբ մեթոդը օգտագործվում է արտադրական հիմնարկություններում կամ աշխատանքային սենյակներում աշխատանքային հորիզոնական մակերեսի միջին արհեստական լուսավորվածությունը հաշվելու համար: Այս մեթոդը կիրառվում է ինչպես աշխատատեղերի ընդհանուր մակերեսի հավասարաչափ լուսավորվածությունը հաշվելու համար, այնպես էլ արտացոլված կամ սփռված լույս տարածող լուսամփոփների օգտագործման դեպքում: Այս մեթոդը կախված է լամպի լուսային հոսքի հաշվարկից, լուսամփոփների քանակից և տեղադրման ուրվագծից: Լուսավորվածության հաշվարկների մեթոդի էությունը, լուսային հոսքի գործակցի օգտագործման միջոցով, կայանում է նրանում, որ հաշվի են առնվում ինչպես ուղիղ լույսը, այնպես էլ աշխատասեղանին պատերից, առաստաղից և հատակից ընկած կամ անդրադարձված լույսը: 

Յուրաքանչյուր լամպի լույսի հոսքը որոշվում է հետևյալ բանաձևով.
$$F_L = ( E_ն \cdot S \cdot Z \cdot K ) / (n \cdot ղ )   (լմ)  (*)$$
որտեղ`

$F_L$–ը լամպի անհրաժեշտ հաշվարկային լուսային հոսքն է, 

$E_ն$–ը նորմավորված նվազագույն լուսավորվածությունն է և $E_ն = 500 լք$,

$S$–ը  աշխատասենյակի լուսավորվող մակերևույթի մակերեսն է, որը որոշվում է հետևյալ բանաձևով`            

$$S = ab$$

որտեղ ՝

$a$–ն աշխատասենյակի երկարությունն է՝  $a = 5 մ$

$b$ –ն աշխատասենյակի լայնությունն է՝  $b = 4 մ$

հետևաբար         

$$S = 54 = 20 (մ^2)$$ 

$K$–ն կոչվում է պաշարի գործակից և սովորաբար ընդունում է 1.5 արժեքը,

$n=3$՝ աշխատասենյակում տեղադրված լուսամփոփների քանակն է,

$ղ$ –ն լամպի լույսի օգտագործման գործակիցն է, որը կախված է լամպի տեսակից, դիրքից, աշխատասենյակի չափերից և առաստաղի, հատակի ու պատերի անդրադարձման գործակիցներից: Տվյալ աշխատասենյակին համապատասխանում են հետևյալ անդրադարձման գործակիցները`  $p_{պատ} = 50\%$,  $p_{հատ} = 10\%$, $p_{առ} =70\%$

$ղ$ օգտագործման գործակիցը կախված է նաև $i$ ցուցանիշից, որը որոշվում.                        
$$i = ( a\cdot b ) / h_{աշխ}  ( a + b )$$

որտեղ` $h_{աշխ}$–ը սենյակի հաշվարկային բարձրությունն է և որոշվում է հետևյալ բանաձևով`

$$h_{աշխ} = h_{ընդ} - ( h_{մակ} + h_լ )$$

$h_{ընդ}= 3 մ$` տվյալ աշխատասենյակի բարձրությունն է,  hմակ= 0,8 մ  և  hլ= 0,2 մ; հետևաբար՝
$$h_{աշխ} = 3 – (0,8 + 0,2) = 2 (մ)$$
Տեղադրելով համապատասխան բանաձևի մեջ՝ կստանանք. 
$$i = ( 54 ) / 2 ( 5 + 4 ) = 20/18 = 1,1$$
Հաշվարկներից ստացված արժեքներին համապատասխանում է ղ օգտագործման գործակցի հետևյալ արժեքը` $ղ = 0,46$

$Z$–ը գործակից է, որը հաշվի է առնում լուսավորվածության անհամասեռությունը, այն կախված է  տեղադրված լուսային աղբյուրների միջև եղած հեռավորությունից և լուսավորվածության բաշխվածությունից: Եթե լուսային աղբյուրների միջև ընկած տարածությունը հասնում է օպտիմալին կամ քիչ է դրանից, ապա $Z = 1,1-1,15$: Կարելի է կիրառել լուսամփոփների լուսավորման ուղիղ լույսի տարբերակը: Այդ դեպքում $Z = 1,15$: Իսկ մնացած դեպքում կարելի է ընդունել $Z=1,1$: Տվյալ դեպքում համապատասխանում է $Z$–ի հետևյալ արժեքը` $Z=1,1$: Տեղադրելով ստացված արժեքը (*)–ում կստանանք

$$F_L = ( 500151,11,5 ) / ( 30,46 ) = 12375/1,38 = 8967,39 (լմ)$$

Օգտվելով ստացված տվյալներից՝ կարող ենք հաշվել ընդհանուր լուսավորվածությունը հետևյալ բանաձևով.              

$$E = ( F_L\cdot n\cdot ղ ) / ( S\cdot K\cdot Z ) (լք)$$
$$E = (8967,39\cdot 3\cdot 0,46) / (20\cdot 1,5\cdot 1,1) = 16141,302 / 33 = 489,5 (լք)$$

Այսպիսով, ստացանք տվյալ աշխատասենյակի լուսավորվածության և լուսավորվածության հոսքի հետևյալ արժեքները`   

$$E = 489,5 (լք)$$
և
$$F_L = 8967,39 (լմ)$$

Այս արժեքները համապատասխանում են արհեստական լուսավորվածության օպտիմալ պայմաններին:




\cftaddtitleline{toc}{section}{Բնապահպանության բաժին}{44}
\cftaddtitleline{toc}{section}{Կենսագործունեության անվտանգության բաժին}{51}
\cftaddtitleline{toc}{section}{Տնտեսագիտական բաժին}{55}
\newpage
\includepdf[pages={-}]{tntes.pdf}

\end{sloppypar}
\end{document}
